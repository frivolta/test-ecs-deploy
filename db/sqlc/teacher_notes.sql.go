// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: teacher_notes.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTeacherNote = `-- name: CreateTeacherNote :one
INSERT INTO teacher_notes(note, teacher_id, date)
VALUES ($1, $2, $3)
RETURNING id, note, teacher_id, date
`

type CreateTeacherNoteParams struct {
	Note      string        `json:"note"`
	TeacherID sql.NullInt64 `json:"teacherID"`
	Date      time.Time     `json:"date"`
}

func (q *Queries) CreateTeacherNote(ctx context.Context, arg CreateTeacherNoteParams) (TeacherNote, error) {
	row := q.db.QueryRowContext(ctx, createTeacherNote, arg.Note, arg.TeacherID, arg.Date)
	var i TeacherNote
	err := row.Scan(
		&i.ID,
		&i.Note,
		&i.TeacherID,
		&i.Date,
	)
	return i, err
}

const getAllTeacherNotes = `-- name: GetAllTeacherNotes :many
SELECT id, note, teacher_id, date
FROM teacher_notes
ORDER BY id
`

func (q *Queries) GetAllTeacherNotes(ctx context.Context) ([]TeacherNote, error) {
	rows, err := q.db.QueryContext(ctx, getAllTeacherNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeacherNote{}
	for rows.Next() {
		var i TeacherNote
		if err := rows.Scan(
			&i.ID,
			&i.Note,
			&i.TeacherID,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherNote = `-- name: GetTeacherNote :one
SELECT id, note, teacher_id, date
FROM teacher_notes
WHERE id = $1
`

func (q *Queries) GetTeacherNote(ctx context.Context, id int64) (TeacherNote, error) {
	row := q.db.QueryRowContext(ctx, getTeacherNote, id)
	var i TeacherNote
	err := row.Scan(
		&i.ID,
		&i.Note,
		&i.TeacherID,
		&i.Date,
	)
	return i, err
}

const getTeacherNotesByDate = `-- name: GetTeacherNotesByDate :many
SELECT teacher_notes.id,
       note,
       date,
       teachers.name    AS "teacher_name",
       teachers.surname AS "teacher_surname",
       teachers.id      AS "teacher_id"
FROM teacher_notes
         LEFT JOIN teachers ON teacher_notes.teacher_id = teachers.id
WHERE date = $1
`

type GetTeacherNotesByDateRow struct {
	ID             int64          `json:"id"`
	Note           string         `json:"note"`
	Date           time.Time      `json:"date"`
	TeacherName    sql.NullString `json:"teacherName"`
	TeacherSurname sql.NullString `json:"teacherSurname"`
	TeacherID      sql.NullInt64  `json:"teacherID"`
}

func (q *Queries) GetTeacherNotesByDate(ctx context.Context, date time.Time) ([]GetTeacherNotesByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherNotesByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeacherNotesByDateRow{}
	for rows.Next() {
		var i GetTeacherNotesByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Note,
			&i.Date,
			&i.TeacherName,
			&i.TeacherSurname,
			&i.TeacherID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherNotesByPeriod = `-- name: GetTeacherNotesByPeriod :many
SELECT teacher_notes.id,
       note,
       date,
       teachers.name    AS "teacher_name",
       teachers.surname AS "teacher_surname",
       teachers.id      AS "teacher_id"
FROM teacher_notes
         LEFT JOIN teachers ON teacher_notes.teacher_id = teachers.id
WHERE date >= $1
  AND date <= $2
ORDER BY date DESC
`

type GetTeacherNotesByPeriodParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date2"`
}

type GetTeacherNotesByPeriodRow struct {
	ID             int64          `json:"id"`
	Note           string         `json:"note"`
	Date           time.Time      `json:"date"`
	TeacherName    sql.NullString `json:"teacherName"`
	TeacherSurname sql.NullString `json:"teacherSurname"`
	TeacherID      sql.NullInt64  `json:"teacherID"`
}

func (q *Queries) GetTeacherNotesByPeriod(ctx context.Context, arg GetTeacherNotesByPeriodParams) ([]GetTeacherNotesByPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherNotesByPeriod, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeacherNotesByPeriodRow{}
	for rows.Next() {
		var i GetTeacherNotesByPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.Note,
			&i.Date,
			&i.TeacherName,
			&i.TeacherSurname,
			&i.TeacherID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNote = `-- name: UpdateNote :one
UPDATE teacher_notes
SET note=$2,
    date=$3
WHERE id = $1
RETURNING id, note, teacher_id, date
`

type UpdateNoteParams struct {
	ID   int64     `json:"id"`
	Note string    `json:"note"`
	Date time.Time `json:"date"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) (TeacherNote, error) {
	row := q.db.QueryRowContext(ctx, updateNote, arg.ID, arg.Note, arg.Date)
	var i TeacherNote
	err := row.Scan(
		&i.ID,
		&i.Note,
		&i.TeacherID,
		&i.Date,
	)
	return i, err
}
